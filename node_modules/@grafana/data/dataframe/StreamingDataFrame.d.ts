import { Field, DataFrame } from '../types/dataFrame';
import { QueryResultMeta } from '../types';
import { ArrayVector } from '../vector';
import { DataFrameJSON } from './DataFrameJSON';
/**
 * @alpha
 */
export interface StreamingFrameOptions {
    maxLength?: number;
    maxDelta?: number;
}
/**
 * Unlike a circular buffer, this will append and periodically slice the front
 *
 * @alpha
 */
export declare class StreamingDataFrame implements DataFrame {
    name?: string;
    refId?: string;
    meta?: QueryResultMeta;
    fields: Array<Field<any, ArrayVector<any>>>;
    length: number;
    options: StreamingFrameOptions;
    private schemaFields;
    private timeFieldIndex;
    private pushMode;
    private labels;
    constructor(frame: DataFrameJSON, opts?: StreamingFrameOptions);
    /**
     * apply the new message to the existing data.  This will replace the existing schema
     * if a new schema is included in the message, or append data matching the current schema
     */
    push(msg: DataFrameJSON): void;
    private addLabel;
}
export declare function transpose(vrecs: any[][]): Map<any, any>;
